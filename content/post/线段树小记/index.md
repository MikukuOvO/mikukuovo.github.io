---
title: 线段树小记
summary: 算法竞赛中的线段树
date: 2023-10-27
---

### 写在前面
> 此文是本人对于线段树的一些总结和归纳，在退役两年后再次重新系统的学习了一遍线段树，也有了一些新的感悟和体会，故在这里与各位分享，如果有错的地方希望各位加以指正，本文涉及的绝大多数例题都在文末给出了题目和代码链接，需要的可以自行查阅。

### 引入

线段树是算法竞赛中常用的维护区间信息的一种数据结构，其大多数能处理的情况一般为区间信息具有可并性，举例说明：

> 已知一个数列，有以下的两种操作：1.将区间 $[l,r]$ 中的数全部加上 $k$。2.查询区间 $[l,r]$ 所有数的和。

我们考虑一个区间 $[l,r]$ 的和其实就相当于 $[l,i]$ 的和加上 $(i,r]$ 的和（其中 $l \leq i \leq r$ ），这样我们询问一个区间的和就可以拆成询问两个子区间的和，这个也就是上文所说的**可并性**。

再举一个例子：

> 已知一个数列，有以下的两种操作：1.将某点 $p$ 的数修改为 $k$。2.查询区间 $[l,r]$ 最大的数是多少。

同理，我们有 $max_{i=l}^{r} a_i=max(max_{i=l}^ka_i,max_{i=k+1}^ra_i)$ ，我们可以同样的把原区间拆成两个子区间进行统计，我们发现最值运算同样具有**可并性**。

一般的，如果两个相邻区间信息能在常数的复杂度下通过某种运算合并成一个区间，那么我们就称这种运算具有**可并性**。

**可并性**可以给统计带来巨大的好处，我们考虑上述的两个问题，如果我们能够记录若干个区间的答案（比如能记录若干个形如 $(l,r)$ 的区间的最值），那么我们怎样去进行选择才能使得时空复杂度尽可能小，我们不难想到每一次将整个区间对半分是一种优秀的策略。

线段树就是这样的一种数据结构，其大致思想就是将一整个区间 $[1,n]$ 每次对半分成两个区间，一直分到区间长度为 1 为止，一般的，对于一个区间 $[l,r]$ ，我们会将其分为 $[l,mid]$ 和 $(mid,r]$ 两个区间。

### 性质
我们考虑线段树具有的一些性质：

线段树的高度的数量级为 $log_2n$ ，这个根据我们对半分区间的做法可知，同样这使得我们对于一个单点进行改动所会影响的线段树中点数的数量级同样为 $log_2n$。 我们定义 $f(l,r)$ 为我们所要维护的区间 $(l,r)$ 的信息，那么我们有 $f(l,r)=f(l,mid)\odot f(mid+1,r)$，其中我们定义运算 $\odot$ 为将两个区间的信息合并，我们考虑线段树上存在的点，如果 $\forall o \in SegementTree$ ，并且 $o$ 存在两个儿子 $ls,rs$ ，那么我们就有 $f(s(o))=f(s(ls))\odot f(s(rs))$，其中 $s(o)$ 表示 $o$ 所指的区间。 对于任意一个区间 $(l,r)$ 我们可以将其分为 $log_2n$ 数量级个**线段树上存在**的区间，这个性质的证明等价于任意一个正整数可以被拆成若干个不等的形如 $2^i$ 的数之和，这也就意味着在线段树上进行 $n$ 次基本操作的时间复杂度以及线段树本身的空间复杂度都为 $\mathcal{O}(nlogn)$。